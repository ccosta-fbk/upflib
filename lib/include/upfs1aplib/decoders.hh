#ifndef UPFS1APLIB_DECODERS_HH
#define UPFS1APLIB_DECODERS_HH

#include <upfnetworklib/networklib.hh>

#include <algorithm>
#include <functional>
#include <string>
#include <vector>

// Forward declaration of some types in the same way ASN1Lib
// does, so we can freely use pointers or references to it without
// including all C stuff here
extern "C" {
struct S1AP_S1AP_PDU;
typedef S1AP_S1AP_PDU S1AP_S1AP_PDU_t;
}

namespace UPF {

/// @brief Cross-platform code specifically dealing with S1AP.
namespace S1APLib {
/**
 * @brief Decode a S1AP PDU (using the code generated by asn1c in
 *        ASN1Lib) stored in the given BufferView.
 */
class S1APDecoder {
  public:
    ///@name Constructors
    ///@{

    /// @brief Constructor specifying a BufferView containing the
    ///        S1AP-PDU data.
    S1APDecoder(const NetworkLib::BufferView &s1apData);

    ///@}

    ///@name No default constructor
    ///@{
    S1APDecoder() = delete;
    ///@}

    ///@name No copy semantics
    ///@{
    S1APDecoder(const S1APDecoder &) = delete;
    S1APDecoder &operator=(const S1APDecoder &) = delete;
    ///@}

    ///@name No move semantics
    ///@{
    S1APDecoder(S1APDecoder &&) noexcept = delete;
    S1APDecoder &operator=(S1APDecoder &&) = delete;
    ///@}

    /// @brief Destructor
    ~S1APDecoder();

    /// @brief Provide access to decoded data
    const S1AP_S1AP_PDU_t &getS1AP_PDU() const { return *mPDU; }

  private:
    // Not owned
    const NetworkLib::BufferView mBufferView;

    // Pointer to decoded data, *owned*
    //
    // Note: not a std::unique_ptr because it has its custom C
    //       functions to allocate/deallocate it.
    S1AP_S1AP_PDU_t *mPDU;
};

/**
 * @brief Simple decoder for NAS (Network Access Stratum) data.
 *
 * It actually extracts only plain NAS data.
 */
class NASDecoder {
  public:
    /// @brief Constructor specifying a BufferView containing the
    ///        NAS data.
    NASDecoder(const NetworkLib::BufferView &nasData) : mBufferView(nasData) {}

    // No default constructor
    NASDecoder() = delete;

    ///@name No copy semantic
    ///@{
    NASDecoder(const NASDecoder &) = delete;
    NASDecoder &operator=(const NASDecoder &) = delete;
    ///@}

    ///@name No move semantic
    ///@{
    NASDecoder(NASDecoder &&) noexcept = delete;
    NASDecoder &operator=(NASDecoder &&) = delete;
    ///@}

    /// @brief Return a BufferView containing the NAS plain data.
    const NetworkLib::BufferView getNASPlainData() const {
        // See 3GPP TS 24.301 sec. 9.1, 9.2 and 9.8
        const std::uint8_t protocolDiscriminator =
            mBufferView.getUint8At(0) & 0x0F;
        const std::uint8_t securityHeader =
            (mBufferView.getUint8At(0) >> 4) & 0x0F;

        // See 3GPP TS 24.301 sect. 9.2 and
        // 3GPP TS 24.007 sect. 11.2.3.1
        if (protocolDiscriminator == 0x07 && securityHeader != 0) {
            // Value 0x07 is for "EPS mobility management messages",
            // and thus this is a security protected NAS message. A
            // plain NAS message therefore starts at the 7th octet (offset = 6).
            return mBufferView.getSub(nasPlainOffset,
                                      mBufferView.size() - nasPlainOffset);

        } else {
            // This is already a plain NAS message.
            return mBufferView;
        }
    }

  private:
    // Offsets
    enum {
        nasPlainOffset = 6,
    };

    // NAS data. Not owned.
    NetworkLib::BufferView mBufferView;
};

/**
 * @brief Decode a PDN address as described by 3GPP TS 24.301
 *        sect. 9.9.4.9.1. (IEI and length not included)
 */
class PDNAddressDecoder {
  public:
    ///@name Constructors
    ///@{

    /// @brief Constructor specifying a BufferView containig the PDN
    ///        address data.
    PDNAddressDecoder(const NetworkLib::BufferView &addressContent)
        : mBufferView(addressContent) {}

    ///@}

    ///@name No default constructor
    ///@{
    PDNAddressDecoder() = delete;
    ///@}

    ///@name No copy semantic
    ///@{
    PDNAddressDecoder(const PDNAddressDecoder &) = delete;
    PDNAddressDecoder &operator=(const PDNAddressDecoder &) = delete;
    ///@}

    ///@name No move semantic
    ///@{
    PDNAddressDecoder(PDNAddressDecoder &&) = delete;
    PDNAddressDecoder &operator=(PDNAddressDecoder &&) = delete;
    ///@}

    /// @brief Return the IPv4 part of a PDN address.
    ///
    /// If the PDN address does not specify any IPv4 address,
    /// return a zero IPv4 address.
    NetworkLib::IPv4Address getIPv4Address() const {
        const auto pdnAddressType =
            mBufferView.getUint8At(pdnAddressTypeOffset) & 0x07;

        if (pdnAddressType == IPv4) {
            return mBufferView.getIPv4AddressAt(ipv4OnlyAddressOffset);
        } else if (pdnAddressType == IPv4v6) {
            // Return the IPv4 part of the address.
            ///
            // Note that the IPv6 part is not an IPv6 address, but
            // the ifIndex of a IPv6 interface.
            return mBufferView.getIPv4AddressAt(ipv4v6ipv4AddressOffset);
        } else {
            // Non-IP, or IPv6.
            // Return an empty IPv4 address
            return NetworkLib::IPv4Address();
        }
    }

  private:
    // Constant offsets, in bytes, of fields
    enum {
        pdnAddressTypeOffset = 0,
        ipv4OnlyAddressOffset = 1,
        ipv4v6ipv4AddressOffset = 9,
    };

    // Kinds of PDN address
    enum {
        IPv4 = 0x01,
        IPv6 = 0x02,
        IPv4v6 = 0x03,
        nonIP = 0x05,
    };

    NetworkLib::BufferView mBufferView;
};

/**
 * @brief Decode a plain NAS attachAccept message.
 */
class NASPlainAttachAcceptDecoder {
  public:
    ///@name Constructors
    ///@{

    /// @brief Constructor specifying a BufferView containing NAS
    ///        plain data.
    NASPlainAttachAcceptDecoder(const NetworkLib::BufferView &nasPlainData)
        : mBufferView(nasPlainData) {}
    ///@}

    ///@name No default constructor
    ///@{
    NASPlainAttachAcceptDecoder() = delete;
    ///@}

    ///@name No copy semantic
    ///@{
    NASPlainAttachAcceptDecoder(const NASPlainAttachAcceptDecoder &) = delete;
    NASPlainAttachAcceptDecoder &
    operator=(const NASPlainAttachAcceptDecoder &) = delete;
    ///@}

    ///@name No move semantic
    ///@{
    NASPlainAttachAcceptDecoder(NASPlainAttachAcceptDecoder &&) = delete;
    NASPlainAttachAcceptDecoder &
    operator=(NASPlainAttachAcceptDecoder &&) = delete;
    ///@}

    ///@name Read access to header fields
    ///@{

    std::uint8_t getMessageType() const {
        return mBufferView.getUint8At(messageTypeOffset);
    }

    ///@}

    ///@name Utilities
    ///@{

    bool isAttachAcceptMessage() const {
        return getMessageType() == attachAcceptMessageType;
    }

    /// @brief Get a BufferView with the ESM message container field
    //         content (without the first 2 bytes telling its length).
    NetworkLib::BufferView getESMMessageContainerData() const {

        // The TAI list is mandatory at a fixed offset. It's a
        // variable-length LV field (see 3GPP TS 24.301 sect. 8.2.1.1)
        // First octet indicates length.
        //
        // The ESM message container field is mandatory, its length is
        // variable (it's an LV-E) and comes right after the TAI
        // list.
        //
        const std::size_t taiListLenght = mBufferView.getUint8At(taiListOffset);

        // Note: "+ 1" because the TAI list length does not include
        //       the octet with the length.
        const std::size_t esmMsgContainerOffset =
            taiListOffset + 1 + taiListLenght;

        // The first two bytes tell the length (in network byte order)
        const std::size_t esmMsgContainerSize =
            mBufferView.getUint16At(esmMsgContainerOffset);

        // Return the ESM message container data without the length
        return mBufferView.getSub(esmMsgContainerOffset + 2,
                                  esmMsgContainerSize);
    }

    ///@}

  private:
    // Constant offsets, in bytes, of header fields
    enum {
        messageTypeOffset = 1,
        taiListOffset = 4,
    };

    // MessageType values
    enum {
        attachAcceptMessageType = 0x42,
    };

    // The NAS Attach Accept data. Not owned
    NetworkLib::BufferView mBufferView;
};

/**
 * @brief Decode a ACTIVATE DEFAULT EPS BEARER CONTEXT REQUEST.
 *
 * (see 3GPP TS 24.301 sect. 8.3.6.1).
 *
 *  According to sect. 9.8.2, the Activate Default EPS Bearer Context
 *  Request has message type = 0xc1
 *
 */
class NASActivateDefaultEPSBearerContextDecoder {
  public:
    ///@name Constructors
    ///@{

    /// @brief Constructor specifying a BufferView storing a ESM
    ///        message container describing the request.
    ///
    /// Note: message content does not include length
    NASActivateDefaultEPSBearerContextDecoder(
        const NetworkLib::BufferView &esmMessageContent)
        : mBufferView(esmMessageContent) {
        init();
    }

    ///@}

    ///@name No default constructor
    ///@{
    NASActivateDefaultEPSBearerContextDecoder() = delete;
    ///@}

    ///@name No copy semantic
    ///@{
    NASActivateDefaultEPSBearerContextDecoder(
        const NASActivateDefaultEPSBearerContextDecoder &) = delete;
    NASActivateDefaultEPSBearerContextDecoder &
    operator=(const NASActivateDefaultEPSBearerContextDecoder &) = delete;
    ///@}

    ///@name No move semantic
    ///@{
    NASActivateDefaultEPSBearerContextDecoder(
        NASActivateDefaultEPSBearerContextDecoder &&) noexcept = delete;
    NASActivateDefaultEPSBearerContextDecoder &
    operator=(NASActivateDefaultEPSBearerContextDecoder &&) = delete;
    ///@}

    ///@name Read access to request fields
    ///@{

    std::string getAccessPointName() const {
        return mAccessPointNameContent.getLVCompositeString('.');
    }

    NetworkLib::IPv4Address getPDNAddressIPv4() const {
        return PDNAddressDecoder(mPdnAddressContent).getIPv4Address();
    }

    ///@}

  private:
    // Precompute buffers for fields
    void init() {
        // First, we have the EPS QOS field, which is a mandatory LV field at a
        // fixed offset
        std::size_t offset = epsQOSOffset;

        // Mandatory LV field
        mEpsQOSContent =
            mBufferView.getSub(offset + 1, mBufferView.getUint8At(offset));
        offset += mEpsQOSContent.size() + 1;

        // Mandatory LV field
        mAccessPointNameContent =
            mBufferView.getSub(offset + 1, mBufferView.getUint8At(offset));
        offset += mAccessPointNameContent.size() + 1;

        // Mandatory  LV field
        mPdnAddressContent =
            mBufferView.getSub(offset + 1, mBufferView.getUint8At(offset));
    }

    enum {
        messageTypeOffset = 2,
        epsQOSOffset = 3,
    };

    // Content of the whole message (not owned)
    const NetworkLib::BufferView mBufferView;

    // Buffers for fields at variable offsets (not owned)
    NetworkLib::BufferView mEpsQOSContent;
    NetworkLib::BufferView mAccessPointNameContent;
    NetworkLib::BufferView mPdnAddressContent;
};

} // namespace S1APLib
} // namespace UPF
#endif
