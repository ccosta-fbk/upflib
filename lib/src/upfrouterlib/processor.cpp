#include <upfrouterlib/processor.hh>

// For ASN1Lib definitions of S1AP structures.
extern "C" {
#include <S1AP_E-RABToBeSetupListCtxtSUReq.h>
#include <S1AP_InitialContextSetupRequest.h>
#include <S1AP_InitialContextSetupResponse.h>
#include <S1AP_InitiatingMessage.h>
#include <S1AP_ProtocolIE-Field.h>
#include <S1AP_S1AP-PDU.h>
#include <S1AP_SuccessfulOutcome.h>
#include <asn_application.h>
}

namespace UPF {
namespace UPFRouterLib {

// A S1AP_TransportLayerAddress_t is a opaque bit array, but in
// practice it is a 32-bit IPV4 address.
static NetworkLib::IPv4Address
toIPv4Address(const S1AP_TransportLayerAddress_t &tlAddress) {
    if ((tlAddress.size == 4) && (tlAddress.bits_unused == 0)) {
        return NetworkLib::IPv4Address(tlAddress.buf[0], tlAddress.buf[1],
                                       tlAddress.buf[2], tlAddress.buf[3]);
    }

    return NetworkLib::IPv4Address();
}

// A S1AP_GTP_TEID_t in practice is an octet string or four octets.
static NetworkLib::GTP_TEID::Number toGTP_TEID(const S1AP_GTP_TEID_t &obj) {
    if (obj.size == 4) {
        return NetworkLib::GTP_TEID::Number(NetworkLib::getUint32At(obj.buf));
    }
    return NetworkLib::GTP_TEID::Number(0);
}

bool Processor::processS1AP(Context &context) {

    // Note: redundant checks, in theory.

    if ((context.s1apDecoder != nullptr) && (context.ipv4Decoder != nullptr) &&
        (context.sctpDecoder != nullptr)) {

        processPDU(context.s1apDecoder->getS1AP_PDU(), context);
    }

    return true;
}

bool Processor::processInitialContextSetupRequest(
    const S1AP_InitialContextSetupRequest_t &request, Context &context) {

    // This is a InitialContextSetupRequest
    std::uint32_t mme_ue_s1ap_id = 0;
    std::uint32_t enb_ue_s1ap_id = 0;

    // Potentially up to 256 items -- in practice it's just 1
    InitialContextSetupRequests_t reqs(context);

    // Alias.  It is a sequence of S1AP_InitialContextSetupRequestIEs,
    // each representing a field of the
    // InitialContextSetupRequest. There are 26 fields circa, we are
    // interested only in few of them
    const auto &protocolIEs = request.protocolIEs.list;

    for (int i = 0; i < protocolIEs.count; ++i) {

        // Alias (S1AP_InitialContextSetupRequestIEs)
        const auto &protocolIEs_item = *(protocolIEs.array[i]);

        switch (protocolIEs_item.value.present) {
        case S1AP_InitialContextSetupRequestIEs__value_PR_MME_UE_S1AP_ID:
            // This field is mandatory (1st entry)

            mme_ue_s1ap_id = protocolIEs_item.value.choice.MME_UE_S1AP_ID;
            break;

        case S1AP_InitialContextSetupRequestIEs__value_PR_ENB_UE_S1AP_ID:
            // This field is mandatory (2nd entry)

            enb_ue_s1ap_id = protocolIEs_item.value.choice.ENB_UE_S1AP_ID;
            break;

        case S1AP_InitialContextSetupRequestIEs__value_PR_E_RABToBeSetupListCtxtSUReq:
            // This field is mandatory (4th entry)
            {
                // Alias.
                //
                // It's a S1AP_E_RABToBeSetupListCtxtSUReq_t with a
                // sequence of generic S1AP_ProtocolIE_SingleContainer
                // which are actually
                // S1AP_E_RABToBeSetupItemCtxtSUReqIEs_t items).
                const auto &setupList = protocolIEs_item.value.choice
                                            .E_RABToBeSetupListCtxtSUReq.list;

                // At most 256 entries (see 'maxnoofE-RABs'), each with
                // a E-RABToBeSetupItemCtxtSUReqIEs
                for (int j = 0; j < setupList.count; ++j) {

                    InitialContextSetupRequestData info = {};

                    // Alias.
                    //
                    // Note: reinterpret_cast<>() here is a workraound for
                    //       weird type generation in structs generated by
                    //       asn1c, as the declared type is a
                    //       S1AP_ProtocolIE_SingleContainer, while the
                    //       actual type in this case is a
                    //       S1AP_E_RABToBeSetupItemCtxtSUReqIEs_t

                    const auto &setupList_genericItem = *reinterpret_cast<
                        const S1AP_E_RABToBeSetupItemCtxtSUReqIEs_t *>(
                        setupList.array[j]);

                    // As of 3GPP TS 36.413 v14.4.0, this is the only kind
                    // of item that's allowed (either that, or it's
                    // absent).
                    if (setupList_genericItem.value.present ==
                        S1AP_E_RABToBeSetupItemCtxtSUReqIEs__value_PR_E_RABToBeSetupItemCtxtSUReq) {
                        // Alias
                        const S1AP_E_RABToBeSetupItemCtxtSUReq_t
                            &setupList_item = setupList_genericItem.value.choice
                                                  .E_RABToBeSetupItemCtxtSUReq;

                        info.e_rab_id = setupList_item.e_RAB_ID;
                        info.transportLayerAddress =
                            toIPv4Address(setupList_item.transportLayerAddress);
                        info.gtp_teid = toGTP_TEID(setupList_item.gTP_TEID);

                        // NAS-PDU
                        if (setupList_item.nAS_PDU != nullptr) {
                            S1APLib::NASDecoder nasGenericDecoder(
                                NetworkLib::BufferView::makeNonOwningBufferView(
                                    setupList_item.nAS_PDU->buf,
                                    setupList_item.nAS_PDU->size));
                            S1APLib::NASPlainAttachAcceptDecoder
                                attachAcceptDecoder(
                                    nasGenericDecoder.getNASPlainData());

                            if (attachAcceptDecoder.isAttachAcceptMessage()) {
                                S1APLib::
                                    NASActivateDefaultEPSBearerContextDecoder
                                        dec(attachAcceptDecoder
                                                .getESMMessageContainerData());

                                info.UEIPv4Address = dec.getPDNAddressIPv4();

                                // Append info
                                reqs.requests.push_back(std::move(info));
                            }
                        }
                    }
                }
            }
            break;

        default:
            break;
        }
    }

    // Now that we finished examining all the protocol IEs of the
    // InitialContextSetupRequest, we can set the fields which are
    // common to all E-RABToBeSetupItemCtxtSUReqIEs requests we
    // gathered.
    for (auto &i : reqs.requests) {
        i.mme_ue_s1ap_id = mme_ue_s1ap_id;
        i.enb_ue_s1ap_id = enb_ue_s1ap_id;
    }

    // Call callback if there is data.
    if (!reqs.requests.empty() && mInitialContextSetupRequestCbk != nullptr) {
        return mInitialContextSetupRequestCbk(reqs);
    }

    return true;
}

bool Processor::processInitialContextSetupResponse(
    const S1AP_InitialContextSetupResponse_t &response, Context &context) {
    std::uint32_t mme_ue_s1ap_id = 0;
    std::uint32_t enb_ue_s1ap_id = 0;
    InitialContextSetupResponses_t resps(context);

    // list of S1AP_ProtocolIE_Container_6551P20_t, a list of
    // S1AP_InitialContextSetupResponseIEs
    const auto &protocolIEs = response.protocolIEs.list;

    for (int i = 0; i < protocolIEs.count; ++i) {

        // S1AP_InitialContextSetupResponseIEs
        // Alias (S1AP_InitialContextSetupResponseIEs)
        const auto &protocolIEs_item = *(protocolIEs.array[i]);

        switch (protocolIEs_item.value.present) {
        case S1AP_InitialContextSetupResponseIEs__value_PR_MME_UE_S1AP_ID:
            mme_ue_s1ap_id = protocolIEs_item.value.choice.MME_UE_S1AP_ID;
            break;
        case S1AP_InitialContextSetupResponseIEs__value_PR_ENB_UE_S1AP_ID:
            enb_ue_s1ap_id = protocolIEs_item.value.choice.ENB_UE_S1AP_ID;
            break;
        case S1AP_InitialContextSetupResponseIEs__value_PR_E_RABSetupListCtxtSURes: {
            // Alias (S1AP_E_RABSetupListCtxtSURes_t)
            const auto setupListRes =
                protocolIEs_item.value.choice.E_RABSetupListCtxtSURes.list;

            for (int j = 0; j < setupListRes.count; ++j) {

                InitialContextSetupResponseData info = {};

                // Alias
                const auto &setupListRes_genericItem =
                    *reinterpret_cast<const S1AP_E_RABSetupItemCtxtSUResIEs *>(
                        setupListRes.array[j]);

                if (setupListRes_genericItem.value.present ==
                    S1AP_E_RABSetupItemCtxtSUResIEs__value_PR_E_RABSetupItemCtxtSURes) {
                    const auto &setupListRes_item =
                        setupListRes_genericItem.value.choice
                            .E_RABSetupItemCtxtSURes;

                    info.e_rab_id = setupListRes_item.e_RAB_ID;

                    info.transportLayerAddress =
                        toIPv4Address(setupListRes_item.transportLayerAddress);
                    info.gtp_teid = toGTP_TEID(setupListRes_item.gTP_TEID);

                    resps.responses.push_back(std::move(info));
                }
            }

        } break;

        default:
            break;
        }
    }

    // Now that we finished examining all the protocol IEs of the
    // InitialContextSetupResponse, we can set the fields which are
    // common to all responses we gathered
    for (auto &i : resps.responses) {
        i.mme_ue_s1ap_id = mme_ue_s1ap_id;
        i.enb_ue_s1ap_id = enb_ue_s1ap_id;
    }

    // Call callback if there is data.
    if (!resps.responses.empty() &&
        (mInitialContextSetupResponseCbk != nullptr)) {
        return mInitialContextSetupResponseCbk(resps);
    }

    return true;
}

bool Processor::processPDU(const S1AP_S1AP_PDU_t &pdu, Context &context) {

    if ((pdu.present == S1AP_S1AP_PDU_PR_initiatingMessage) &&
        (pdu.choice.initiatingMessage != nullptr) &&
        (pdu.choice.initiatingMessage->value.present ==
         S1AP_InitiatingMessage__value_PR_InitialContextSetupRequest)) {

        // This is a S1AP InitialContextSetupRequest.
        const auto &request = pdu.choice.initiatingMessage->value.choice
                                  .InitialContextSetupRequest;

        // Process it.
        return processInitialContextSetupRequest(request, context);

    } else if ((pdu.present == S1AP_S1AP_PDU_PR_successfulOutcome) &&
               (pdu.choice.successfulOutcome != nullptr) &&
               (pdu.choice.successfulOutcome->value.present ==
                S1AP_SuccessfulOutcome__value_PR_InitialContextSetupResponse)) {

        // This is a S1AP InitialContextSetupResponse.
        const auto &response = pdu.choice.successfulOutcome->value.choice
                                   .InitialContextSetupResponse;

        // Process it.
        return processInitialContextSetupResponse(response, context);
    } else {
        // Other kind of S1AP traffic. Don't postprocess as IPv4.
        context.postProcessIPv4 = false;
    }

    return true;
}

} // namespace UPFRouterLib
} // namespace UPF
